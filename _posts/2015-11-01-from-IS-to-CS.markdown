---
layout: post
title:  "From Information Systems to Computer Science"
date:   2015-11-01 18:30:00
categories:
excerpt:  "This article covers how I intend to continue my education by improving my understanding of computer science principals."
tags: technology, education, computer science, information systems
---
A little background: I was introduced to writing HTML at the age of ten by a friend of mine. We wrote web pages using his dad’s 386 (with a turbo button, which I loved pressing) with Windows 95, a 28.8k dial-up connection and a program called [Aracnophylia](http://www.arachnoid.com/arachnophilia/index.php). Over several years, my friends and I were posting regularly to our web sites hosted on [Maxpages](http://www.screenshots.com/maxpages.com/2005-07-15), [Angelfire](http://www.angelfire.lycos.com/), [GeoCities](https://en.wikipedia.org/wiki/Yahoo!_GeoCities), and more. In my mid-teenage years, I spent more time designing layouts and customizing the perl-based content management systems that ran on shared hosting services. Without this hobby, I may have never gotten into technology and programming as a career in the first place. Looking back, I can’t imagine doing anything else now.

I took the most computer-oriented classes I could find in high school: computer networking and computer programming. The networking class was taught at the nearby continuing-education facility near my high school (Franklin Technology Center) and was intended to teach students material covered in the Cisco CCNA and the CompTIA A+ certification tests. I didn’t take either because I didn’t see interest in those fields. With the computer programming class, however, I saw potential. The first year was taught in QBASIC and the second in C++. I learned about algorithms, data structures, computational complexity and problem-solving skills through chalkboard instruction, introductory textbooks, and head-scratching trial-and-error programming under the guidance of an excellent mathematics teacher at my high school. I wrote my first programs to manage content for the user here, and I ran into my first problems with conditional branches and matrix math.

(There was another computer-oriented class devoted to multimedia, particularly video editing, but the waiting list was much too long for me to get in.)

I decided to attend Missouri State University in the spring of 2005. I reviewed the degree programs offered at MSU (the regional abbreviation for [Missouri State](https://missouristate.edu)) and quickly narrowed down my choices. Either I was going to pursue a bachelors in Computer Science (CSC) or a bachelors in Computer Information Systems (CIS). Both claimed to get students ready for careers in software development. I liked what I saw of the core classes in both programs, so my decision was a real nail-biter.

[Computer Science](https://computerscience.missouristate.edu/) offered courses on artificial intelligence, machine learning, data mining and computer vision. [Computer Information Systems](https://cis.missouristate.edu) had courses on desktop applications and web applications. I wanted to take all of them! Some things I noticed differentiating the programs were that the comp sci courses almost seemed like a history lesson with classes on compilers and low-level program (which I didn’t see much use for at the time). The information systems courses placed more focus on technologies in corporate IT, such as web frameworks and database management. Comp sci placed extra emphasis on mathematics. While I considered myself to be a good math student (I earned an ‘A' in Calc AP, after-all!), I feared the level of mathematical intensity that college would bring. Perhaps I suffered (prematurely) from [impostor syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome) or perhaps I was afraid of the rigorous challenge that advanced math and physics courses would put on my workload. Either way, at the time I wasn’t sure if I could rise to the challenge of that level of intense study.

Computer information systems, on the other hand, was run out of the [College of Business](https://business.missouristate.edu). While I had not taken any business courses in high school, I always had an interest in learning business. This is because my grandfather was a successful small business owner, starting with a Western wear store and finishing with a trucking company. Here’s the thing I didn’t know when I was younger: he only had a high school education. He never went to college, let alone a business school. My grandfather was given an opportunity buy his boss’s shoe repair shop. Everything he learned about running a business was through experience.

In the spring of 2005 I had the chance to speak with the Dean of the CIS program and I really liked him as a person and what he told me about the program. The presentation materials for the CIS program were polished and slick compared to that of the CS program. During the summer of that year, I had some time to have a one-on-one meeting with a college counselor and I asked her what she thinks I should do. Wisely she decided against giving me advice so that I would feel autonomous in my decision. I took a look at some statistics she had available, particularly the hiring rates and starting salaries for CS majors versus CIS majors. The numbers sealed the deal: IS majors had a higher rate of finding employment shortly after college compared to CS majors and IS majors had (slightly) higher starting salaries! With all considered, I signed up for the CIS program, even though my first semester I took an intro class in computer science (which I’m glad I did as it introduced me to the [Python](https://python.org) programming language - still one of my favorites to date).

There were many parts of the CIS program I enjoyed. Any time a course dealt with programming, I was all for it. I was introduced to advanced database administration, Linux administration, information security, front-end web programming, and emerging web frameworks like [ASP.NET MVC](http://www.asp.net/mvc) and [Ruby on Rails](http://rubyonrails.org). Some of my CS dorm-mates were sometimes envious of me being exposed to newer technologies than they were. I also got the impression that computer science courses taught a lot of classical aspects of computer which were less relevant than what is required to get up-and-running with software development today. Now I see a lot of value in teaching the fundamentals and not depending on frameworks as a part of the education process, much in the same way of requiring students do mental math and write steps out on paper rather than rely on their calculators.

There were aspects of the CIS curriculum I was not completely sold on: many of the systems analyst courses focused on creating an inordinate amount of [UML diagrams](https://en.wikipedia.org/wiki/Unified_Modeling_Language). Perhaps the jobs I’ve had since graduating college have not been at firms large enough to warrant their use, but I haven’t seen nearly as many UML diagrams as I did during undergrad. I think most companies realize that doing these diagrams can cause their workforce to perform a lot of busy-work that doesn’t help the implementation process that much (aside from high-level flow charts and user stories here and there). The requirements for code can change so much that having to also modify diagrams to reflect those changes is not time well spent. I was also taught strictly the [waterfall approach](https://en.wikipedia.org/wiki/Software_development_process#Waterfall_model) to managing software development projects. So far in my working life, [agile](https://en.wikipedia.org/wiki/Agile_software_development), [scrum](https://en.wikipedia.org/wiki/Scrum_%28software_development%29), and [Kanban](https://en.wikipedia.org/wiki/Kanban_%28development%29) have been the majority of what I’ve encountered. With that said, I don’t think it is fair for me to fault an academic program on not being too current with the times as far as what is going on in industry.

Rather, I think it is fair to critique what a program does not include (which now I realize I am deficient in). I began reading [Hacker News](https://news.ycombinator.com) regularly since 2009. (One of my friends called it “thinking man’s Reddit” and I feel that is an apt descriptor.) The more I read about [BigTable](https://en.wikipedia.org/wiki/BigTable), [MapReduce](https://en.wikipedia.org/wiki/MapReduce), [functional programming](https://en.wikipedia.org/wiki/Functional_programming), [parallel computing](https://en.wikipedia.org/wiki/Parallel_computing) and [distributed computing](https://en.wikipedia.org/wiki/Distributed_computing), alongside lower-level programming ([compilers](https://en.wikipedia.org/wiki/Compiler), [systems programming](https://en.wikipedia.org/wiki/System_programming), and operating systems), the more I began to feel mistaken by choosing IS instead of CS. These topics are huge now and every business is taking advantage of the power of cloud computing, data analytics at a massive scale, and new ways to improve performance across all aspects of the software stack. Although I have worked as a “software engineer” writing touch-screen applications for embedded linux machines in C++ at an industrial scale manufacturer, I have never manually managed memory or used pointers in my programs: I don’t even know how to use malloc() or free()! Pointer arithmetic is alien to me and I’ve never been asked to put something on the heap rather than the stack.

I’m not going to let my lack of a formal computer science education get me down, though. I’ve met plenty of good developers from all sorts of backgrounds, including information systems, information technology, electrical engineering, mechanical engineering, marketing, English literature, photography, architecture and even some who never went to college and just started working in the field straight out of high school. The one trait I know of these individuals compared to others is that they have all have a genuine interest outside of their jobs and formal education for computer technology. They were all [passionate programmers](http://www.amazon.com/The-Passionate-Programmer-Remarkable-Development/dp/1934356344). I consider myself to fit in this category as well.

I’ve met many computer science and information systems majors who did not have as strong as interest for tech outside of their jobs and that’s fine, too! We all need time to unplug in order to handle the 8-to-5+ weekly hustle. I’ve met many CS majors who went into the field because they had an interest in video games. Do they all end up being game developers? No. From what I see, the majority of jobs for programmers are for [CRUD]y(https://en.wikipedia.org/wiki/CRUD) business apps. There’s no shame in that as most of the start-ups that have gone on to become huge have solved business problems rather than technology problems. Computer science seems to cover a very wide variety of subjects giving students a taste of what’s possible (alongside math, science and liberal art classes to satisfy the requirements of a bachelors degree). There’s no time to specialize that early in a career.

Because the tech job market is so hot right now, a lot of people see it as a great path to get a good-paying job. I can understand that motive for someone who just wants to do their job well and then go home to work on non-computing related side projects (or do more important things in life like spend time with their spouses or take care of their kids). I don’t know of many careers outside of technology in which practitioners are required to keep up with the state-of-the-art on their own dime and time. Those paths exist in technology as well, but career advancement doesn’t happen for those individuals as quickly compared to the people who put in work to upgrade their skills on nights and weekends through work on side projects and continuing education. Other career fields may require this dedication (especially anything to do with art, design, and engineering), but there comes a point in time in which other aspects of life take priority.

I have not come to that point in my life. (Some never do.) With that said, I am dedicating the majority of my spare time for the foreseeable future to become a better developer through these activities:

* Creating side projects
    * This must be my main focus. I want to be exposed to more languages than my current weapon of choice (C#). I have really enjoyed writing Python and I appreciate the utility and ubiquitousness of Javascript, specifically [Node](https://nodejs.org) (despite having reservations about the type system). These languages have vibrant ecosystems that I want to use to develop web and desktop applications with. As far as mobile apps go, I’ve learned a bit about making native Android applications through [Kansas City’s local Google Developer Group](http://gdgkc.org). I started a tutorial project but I haven’t finished it. The class for Android Developer certification through [Udacity](https://udacity.com) is beginning again and I plan to retake the class and complete it. I bought an Macbook Pro recently in order to have the ability to develop for iOS. Unfortunately I do not have an iPhone/iPad to test programs I’d develop for them on hardware. Also the App Store license is $99 a year, which is an investment I’ll have to carefully consider. Swift seems like a good language but I’ve heard from veteran iOS developers that [Objective-C](https://en.wikipedia.org/wiki/Objective-C) offers better performance, downside being that it is a difficult language to learn for someone coming from managed (C#/Java) and dynamic (Python/Javascript) language backgrounds. I’m up to these challenges but I need to start small in order to build momentum and add these projects to my portfolio. Any project I complete will have their source code hosted on [my GitHub profile](https://github.com/jasondevelops) with documentation.
* Reading tech books
    * I purchased [Code Complete](http://cc2e.com/) and [Cracking the Coding Interview](http://www.amazon.com/Cracking-Coding-Interview-6th-Edition/dp/0984782850) based on recommendations from friends and mentors. I plan to read the first book over the course of several months. What I learn from it should be applicable to my career over the long-term. I will read the other book and work through its example problems in order to get ready for technical interviews as necessary. I anticipate learning how to implement algorithms and data structures form scratch: key aspects of any computer science curriculum. A couple of other general software development books which have caught my interest are [Soft Skills](www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397/) and [Clean Code](www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/). I don’t want to overload myself with too many unread hardbacks so I’ve put off these purchases. I enjoy being able to unwind by reading a paper book at the end of the night. The quality of a book is usually much higher in terms of writing style and depth of knowledge compared to a blog article, too. I enjoy reading nonfiction, science fiction, and personal development books, but for the time being I am dedicating my spare time to reading tech-centric material so I can become a better developer. I don’t see much value in buying books on specific languages or frameworks, at least this early in my career, because specifications to technologies change so quickly. It is more convenient for me to get programming help via an electronic reference while I’m programming rather than having to switch focus by looking at a paper book.
* Blogging
    * Writing has its own therapeutic value, even if no one else reads it. Plus I can work on my personal branding and marketing material through a web site that’s more sophisticated than a Facebook page or a Twitter feed. Once I have a collection of side projects, I’m looking forward to creating a portfolio section of my web site to explain them. I want to integrate new web technologies into my web site and also use it as a platform to host my resume, contact form, and anything else for public use.
* Participating in open-source software
    * I consider myself to be a team player in the software field. I’m willing to set aside my ego and do things I wouldn’t normally choose to do as long as it advances a goal I share with my team. This mindset will help me assist with open source projects.Perhaps I could begin by testing new features  at first and then help fix bugs in code. Eventually I’ll be able to implement feature requests and even moderate/administer ongoing projects. I need to figure out what I want to help with first so that I will be able to carve out some time to devote myself to it. There is a local group called [Code for KC](http://codeforkc.org/) which asks developers to work on code projects to make Kansas City a better place to live. Not only would helping with this hacker collective improve my skills, it would also provide a service to the community.
* Learning online (through tutorials and [MOOCs](https://en.wikipedia.org/wiki/Massive_open_online_course))
    * YouTube, [Khan Academy](https://www.khanacademy.org/), and [OpenCourseWare](http://ocw.mit.edu/) fall into this category. I can catch up on mathematics important to programming (such as [linear algebra](http://ocw.mit.edu/courses/mathematics/18-06sc-linear-algebra-fall-2011/) and [discrete mathematics](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/)) without having to enroll in college or pay for tuition! I don’t ever see myself being complacent in my life to just go home and watch Netflix until I fall asleep and wake up to go to work again. By having an attitude of life-long learning, I have the freedom to learn by my own direction and at my own pace. I can make up for my lack of formal computer science education through online a variety of learning resources. I can also use video tutorials as a quick way to get up-to-speed on new programming languages through [PluralSight](https://pluralsight.com/), [Udacity](https://www.udacity.com/), and [CodeSchool](https://www.codeschool.com/). Memberships to these sites cost money but it is easy to get discounts through my employer or through local developer groups. I can cancel and resubscribe as necessary. I can also download lessons for offline use.
* Attending meet-ups and conferences
    * When I moved to Kansas City at the beginning of 2015, I began going to tech-centric [meet-ups](https://www.meetup.com) regularly. At the peak I went to ten meet-ups within two-and-a-half weeks! While I was excited to get out and see others in the field who are passionate about technology, I found that I wasn’t getting much out of these meetings other than having a fun distraction and a little bit of exposure to things I might not normally dive into alone (especially functional programming languages like [Erlang](http://www.erlang.org/) and [Haskell](https://www.haskell.org/) through [Lambda Lounge KC](http://www.meetup.com/lamba-lounge-kc/). My favorite ongoing meet-up group has been [PythonKC](http://www.pythonkc.com) because of the quality of their presentations and the welcoming environment the organizers create for both beginner and more advanced programmers. I also appreciate the structure and polish of the local [Google Developers Group](http://gdgkc.org) I have not been to a tech conference since college and I am looking to change that. I haven’t been given any travel time at my work yet and it is hard to justify attending a conference out of pocket (and out of paid-time off). Plus, while these events are a feast for the mind and provide some education on in-depth topics, they are sort of like longer versions of meet-ups in the sense that they don’t provide a great platform for deep study or for learning-by-doing (which I find to be the best ways I learn). I do find that these events are absolutely terrific for networking, though. I’ve been introduced to many recruiters through these groups and also to people who work at local companies (which are often actively looking to hire). I have also enjoyed seeing different company offices and getting a free meal or snacks (always a plus).
* Working with computer hardware
    * I have an [Arduino](https://www.arduino.cc/), I intend to get a [Raspberry Pi 2](https://www.raspberrypi.org/), and I am interested in [system on a chip](https://en.wikipedia.org/wiki/System_on_a_chip) computers to put in my living room and bedroom. I don’t have any immediate plans to implement projects involving [robots](http://pibot.org/), [homemade security systems](http://www.codeproject.com/Articles/665518/Raspberry-Pi-as-low-cost-HD-surveillance-camera), or [local radio transmitters](http://www.rtl-sdr.com/transmitting-fm-am-ssb-sstv-and-fsq-with-just-a-raspberry-pi/) but I have a feeling that I’ll get into something with these devices down the road.
* Competing in hackathons
    * These are a great way to race against the clock alongside (and against) other developers to get a project done (or get as much work done towards a goal as possible). These events generally have a [LAN party](https://en.wikipedia.org/wiki/LAN_party) feel to their environment (with junk food, music, and all sorts of electronics), which reminds me of times I attended and hosted computer gaming tournaments when I was a teenager. I attended a hackathon hosted by my company in April this year. I’m not going to lie: it was stressful and sometimes chaotic but I learned how to work in a setting full of distractions and with a variety of people I didn’t know that well at first. My team’s project did not win the contest but I’m looking to change that when my company hosts another one at the beginning of 2016. I am also going to attend local hackathons in Kansas City when they pop up. [Virtual hackathons](http://www.hackathon.io/events) appeal to me as well, but participating in these is of lower priority compared to going to in-person events in my area.
* Completing coding challenges ([HackerRank](https://www.hackerrank.com/), [Code Golf](https://codegolf.stackexchange.com/))
    * Purely as exercises in testing one’s algorithmic skills, doing small code challenges will be a great way for me to work in new languages (or use different paradigms with languages I’m already familiar with). Since most of these problems expect the programmer to work on them for a brief period of time (an hour or so), I do them throughout the week. Conversely, these tasks are trivial and won’t be nearly as impressive or useful as taking on bigger side projects.

This is a huge list of to-dos, but I am planning for the long-term (over a year). If I can dedicate 1 or 2 hours a night on the weekdays, then I’ll get more done than if I just leave these activities to the weekends. I’ll need to make sacrifices by neglecting to spend time on non-technical side projects (such as as making music, which I am not looking forward to).

For all prospective students or anyone looking for a career change, if you are enrolled in information systems and you are unsure if you are in the right program, please ask yourself these simple questions:

- Are you decent at math? (As in you don’t significantly suffer from [mathematical anxiety](https://en.wikipedia.org/wiki/Mathematical_anxiety) and you have the will to learn.)
- Are you fairly sure you want to program *at least* for the majority of your early professional career?

If you answer “yes” to both of these, or either of them, please strongly consider enrolling in a computer science or software engineering course of study (or even an information technology degree). By the time I knew that I wasn’t in the right program for my personality type and career interests, I already earned too many credits to start over by taking computer science courses. I wanted to graduate on time and I didn’t want to spend any more money on education. After looking at the [ACM’s Curricula Recommendations](http://www.acm.org/education/curricula-recommendations), I think the best degree program for me would have been Software Engineering or Information Technology over Computer Science. These two programs best reflect the skills I feel that match my interests and that provide the most to my current and future employers.  

Now, if you know you aren’t good at math (or at least you don’t think you can’t get better, which is probably not true) or you might like the job of business analyst or project management better, then management information systems (which is different from computer information systems) might be something you’ll enjoy more and get more benefit from in your overall career. I once thought that I might like the work of being a business analyst or a project manager. I’ve looked at what those people do in those roles and I have quickly come to the conclusion that I prefer writing code and making software to writing requirements documents and making Gantt charts. I know those jobs offer great salaries and provide a vital service to business: I just don’t find them nearly as interesting and I don’t think my abilities would be best used in those roles.

The upside of choosing IS over CS is that I did not have to take any deficiency courses to start an MBA curriculum. I’ve contemplated pursuing a masters in computer science, but I’d definitely have to take many deficiency courses. For now I think my formal education is done. After all, a degree
doesn't determine what you'll do for the rest of your life!  It just gets you familiar with a field of study and a small glimpse of what’s possible in your field. After school, you got to keep learning, no matter where you started from.
